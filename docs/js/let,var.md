# let和var

## let和var的区别
let 声明的范围是块作用域，而 var 声明的范围是函数作用域。
```js
if (true) {
 var name = 'QAQ';
 console.log(name); // QAQ
}
console.log(name); // QAQ

if (true) {
 let age = 26;
 console.log(age); // 26
}
console.log(age); // ReferenceError: age 没有定义
```
在这里，age 变量之所以不能在 if 块外部被引用，是因为它的作用域仅限于该块内部。块作用域
是函数作用域的子集，因此适用于 var 的作用域限制同样也适用于 let。

### 暂时性死区
```js
// name 会被提升
console.log(name); // undefined
var name = 'QAQ';

console.log(age); // ReferenceError：age 没有定义
let age = 26; 
```
在解析代码时，JavaScript 引擎也会注意出现在块后面的 let 声明，只不过在此之前不能以任何方
式来引用未声明的变量。在 let 声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此
阶段引用任何后面才声明的变量都会抛出 ReferenceError。

### 全局的声明
与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性
```js
var name = 'QAQ';
console.log(window.name); // 'QAQ'
let age = 26;
console.log(window.age); // undefined
```
### let不能在同一个作用域内声明两次
```js
{
  let s = 2
  console.log(s) // 2
}
let s = 3
console.log(s) // 3
```
如下代码一执行就会直接报错：Uncaught SyntaxError: Identifier 's' has already been declared
```js
let s = 2
console.log(s)
let s = 3
console.log(s) //
```
### for循环中的区别

在 let 出现之前，for 循环定义的迭代变量会渗透到循环体外部：
```js
for (var i = 0; i < 5; ++i) {
 // 循环逻辑
}
console.log(i); // 5
```
改成使用 let 之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部：
```js
for (let i = 0; i < 5; ++i) {
 // 循环逻辑
}
console.log(i); // ReferenceError: i 没有定义
```
要想for循环每隔一秒打印0,1,2,3,4,5这样, 需要加上一个函数作用域去记住i当时的值。
```js
for(var i = 0; i < 6; i++) {
  ((j) => {
    setTimeout(() => {
      console.log(j)
    }, j * 1000)
  })(i)
}
```
如果是let就不需要
```js
for (let i = 0; i < 6; i++) {
  setTimeout(() => {
    console.log(i)
  }, i * 1000)
}
```
## let到底有没有提升
因为查了好些资料。发现有些说的提升有些说的没有提升，社区讨论很激烈。都是站在各自所定义的“提升”的概念上讲的。
对此，我把如下js代码编译成了字节码。执行foo的原因是，v8引擎会优化没有被执行的代码。
```js
function foo() {
  var qaq = 233;
  console.log(qaq);
}

foo();
```
执行
> node --print-bytecode xxx.js  > xxx.txt

:::: code-group
::: code-group-item var的

```c
[generated bytecode for function: foo (0x2fe502d77d11 <SharedFunctionInfo foo>)]
Bytecode length: 21
Parameter count 1
Register count 3
Frame size 24
OSR nesting level: 0
Bytecode Age: 0
   29 S> 0x2fe502d786be @    0 : 00 0d e9 00       LdaSmi.Wide [233]
         0x2fe502d786c2 @    4 : c3                Star0 
   36 S> 0x2fe502d786c3 @    5 : 21 00 00          LdaGlobal [0], [0]
         0x2fe502d786c6 @    8 : c1                Star2 
   44 E> 0x2fe502d786c7 @    9 : 2d f8 01 02       LdaNamedProperty r2, [1], [2]
         0x2fe502d786cb @   13 : c2                Star1 
   44 E> 0x2fe502d786cc @   14 : 5d f9 f8 fa 04    CallProperty1 r1, r2, r0, [4]
         0x2fe502d786d1 @   19 : 0e                LdaUndefined 
   54 S> 0x2fe502d786d2 @   20 : a8                Return 
Constant pool (size = 2)
0x2fe502d78669: [FixedArray] in OldSpace
 - map: 0x309da7f812c1 <Map>
 - length: 2
           0: 0x171c960b90b1 <String[7]: #console>
           1: 0x171c9608c0b1 <String[3]: #log>

```
:::

::: code-group-item let的字节码
```c
[generated bytecode for function: foo (0x1f2c1b037d11 <SharedFunctionInfo foo>)]
Bytecode length: 21
Parameter count 1
Register count 3
Frame size 24
OSR nesting level: 0
Bytecode Age: 0
   29 S> 0x1f2c1b0386be @    0 : 00 0d e9 00       LdaSmi.Wide [233]
         0x1f2c1b0386c2 @    4 : c3                Star0 
   36 S> 0x1f2c1b0386c3 @    5 : 21 00 00          LdaGlobal [0], [0]
         0x1f2c1b0386c6 @    8 : c1                Star2 
   44 E> 0x1f2c1b0386c7 @    9 : 2d f8 01 02       LdaNamedProperty r2, [1], [2]
         0x1f2c1b0386cb @   13 : c2                Star1 
   44 E> 0x1f2c1b0386cc @   14 : 5d f9 f8 fa 04    CallProperty1 r1, r2, r0, [4]
         0x1f2c1b0386d1 @   19 : 0e                LdaUndefined 
   54 S> 0x1f2c1b0386d2 @   20 : a8                Return 
Constant pool (size = 2)
0x1f2c1b038669: [FixedArray] in OldSpace
 - map: 0x1e0d682412c1 <Map>
 - length: 2
           0: 0x3171e69390b1 <String[7]: #console>
           1: 0x3171e690c0b1 <String[3]: #log>
```
:::
::::

得到的结果是两者除了内存地址外，其他地方并没有啥区别

## 声明提升

### 1. 函数优先
函数声明和变量声明都会被提升。但是一个值得注意的细节，是函数会首先被提升，然后才是变量
```js
foo(); // 1
var foo;
function foo () {
  console.log(1);
}
foo = function () {
  console.log(2);
};
```
会输出 1 而不是 2 ！这个代码片段会被引擎理解为如下形式：
```js
function foo() {
  console.log( 1 );
}
foo(); // 1
foo = function() {
  console.log( 2 );
};
```
注意，var foo 尽管出现在 function foo()... 的声明之前，但它是重复的声明（因此被忽
略了），因为函数声明会被提升到普通变量之前。
尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。
```js
foo(); // 3
function foo() {
  console.log( 1 );
}
var foo = function() {
  console.log( 2 );
};
function foo() {
  console.log( 3 );
}
```


### 2. 考虑如下代码
:::: code-group
::: code-group-item 代码
```js
var a = 1;
f();
function f() {
  console.log(a);
  if (false) {
    var a = 2;
  }
}
```
:::
::: code-group-item 结果
```js
var a = 1;
f();
function f() {
  console.log(a); // undefined
  if (false) {
    var a = 2; // 这里的var a会存在变量提升
  }
}

```
:::
::::
如何让它打印1呢？改为let解决问题，但是不能删掉if()，因为提前使用let声明的变量会报错。
```js
var a = 1;
f();
function f() {
  console.log(a);
  if (false) {
    // var a = 2;
    let a = 2;
  }
}

```

### 3. 奇怪的题
即使你对上面的规律很熟悉了。但是碰到这题还是很大概率会弄错！

```js
	var a = 10
	{ 
    console.log('a0', a)
		a = 99;
		function a() {
		}
		a = 30
    console.log('a1', a)
	}
	console.log('a2', a)
```
IE、edge
```js
// a0 function a() {}

// a1 30

// a2 function a() {}
```
Google、Firefox
```js
// a0 ƒ function a() {}

// a1 30

// a2 10
```

## 参考
- [JavaScript Variables Lifecycle: Why let Is Not Hoisted](https://dmitripavlutin.com/variables-lifecycle-and-why-let-is-not-hoisted/#comments)
- [Are variables declared with let or const hoisted?](https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-hoisted/31222689#31222689)
- [let是否存在提升](https://zhuanlan.zhihu.com/p/28140450)
- [理解 V8 的字节码「译」](https://zhuanlan.zhihu.com/p/28590489)
- [JavaScript 引擎 V8 执行流程概述](https://mp.weixin.qq.com/s/t__Jqzg1rbTlsCHXKMwh6A)
- 《你不知道的JavaScript上卷》
- 《javascript高级编程第4版》