<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.51">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>TCP/UDP | Dragon的博客</title><meta name="description" content="Dragon的博客">
    <link rel="modulepreload" href="/assets/app.c901d27c.js"><link rel="modulepreload" href="/assets/tcp_udp.html.b18fa7a7.js"><link rel="modulepreload" href="/assets/tcp_udp.html.36b264f4.js"><link rel="prefetch" href="/assets/index.html.1c9c3412.js"><link rel="prefetch" href="/assets/springboot.html.12389ff2.js"><link rel="prefetch" href="/assets/http.html.947c2389.js"><link rel="prefetch" href="/assets/apply.html.28e5775c.js"><link rel="prefetch" href="/assets/assign.html.2be7c456.js"><link rel="prefetch" href="/assets/bind.html.c475086f.js"><link rel="prefetch" href="/assets/class.html.d209faa3.js"><link rel="prefetch" href="/assets/equal.html.7d66c200.js"><link rel="prefetch" href="/assets/event.html.808bc2b2.js"><link rel="prefetch" href="/assets/function.html.6ecdaa64.js"><link rel="prefetch" href="/assets/instanceof.html.570a569b.js"><link rel="prefetch" href="/assets/let_var.html.bc27ba03.js"><link rel="prefetch" href="/assets/module.html.0f7b2362.js"><link rel="prefetch" href="/assets/new.html.460266aa.js"><link rel="prefetch" href="/assets/promise1.html.f033c91e.js"><link rel="prefetch" href="/assets/promise2.html.23b8e119.js"><link rel="prefetch" href="/assets/scope.html.7972736c.js"><link rel="prefetch" href="/assets/this.html.cde05b96.js"><link rel="prefetch" href="/assets/fractal.html.e828b479.js"><link rel="prefetch" href="/assets/matrixAndTransform.html.28059e9e.js"><link rel="prefetch" href="/assets/cookie和session.html.7cbcdb4a.js"><link rel="prefetch" href="/assets/cors请求.html.ff488a0d.js"><link rel="prefetch" href="/assets/oauth2.0和jwt.html.f9dd3da6.js"><link rel="prefetch" href="/assets/xss与csrf.html.7baefeaf.js"><link rel="prefetch" href="/assets/sort.html.8a275f43.js"><link rel="prefetch" href="/assets/base.html.e69da62f.js"><link rel="prefetch" href="/assets/gymnastics.html.87528ec2.js"><link rel="prefetch" href="/assets/polyfill.html.1411e9c3.js"><link rel="prefetch" href="/assets/tsconfig.html.a6c68a22.js"><link rel="prefetch" href="/assets/babel.html.16e96e69.js"><link rel="prefetch" href="/assets/code.html.5458e928.js"><link rel="prefetch" href="/assets/framework.html.4c316265.js"><link rel="prefetch" href="/assets/index.html.e8ab9f79.js"><link rel="prefetch" href="/assets/react-hooks.html.d45471de.js"><link rel="prefetch" href="/assets/url.html.6cc10f68.js"><link rel="prefetch" href="/assets/vue3.html.b194d42d.js"><link rel="prefetch" href="/assets/webassembly.html.1d989195.js"><link rel="prefetch" href="/assets/webpack1.html.70f93b14.js"><link rel="prefetch" href="/assets/webpack2.html.c264079b.js"><link rel="prefetch" href="/assets/404.html.c3e557d0.js"><link rel="prefetch" href="/assets/index.html.8010e9dd.js"><link rel="prefetch" href="/assets/springboot.html.15e54240.js"><link rel="prefetch" href="/assets/http.html.37b0f5c4.js"><link rel="prefetch" href="/assets/apply.html.035fb7c2.js"><link rel="prefetch" href="/assets/assign.html.97f826b1.js"><link rel="prefetch" href="/assets/bind.html.0d3cdd8d.js"><link rel="prefetch" href="/assets/class.html.d3f26bf4.js"><link rel="prefetch" href="/assets/equal.html.84ea68eb.js"><link rel="prefetch" href="/assets/event.html.7cbefa98.js"><link rel="prefetch" href="/assets/function.html.efcbda2f.js"><link rel="prefetch" href="/assets/instanceof.html.f0e01422.js"><link rel="prefetch" href="/assets/let_var.html.44b9405d.js"><link rel="prefetch" href="/assets/module.html.7760bd1e.js"><link rel="prefetch" href="/assets/new.html.8c5f4bb5.js"><link rel="prefetch" href="/assets/promise1.html.20302601.js"><link rel="prefetch" href="/assets/promise2.html.3a29ddc6.js"><link rel="prefetch" href="/assets/scope.html.2215e49c.js"><link rel="prefetch" href="/assets/this.html.829c09a2.js"><link rel="prefetch" href="/assets/fractal.html.2351cb0c.js"><link rel="prefetch" href="/assets/matrixAndTransform.html.6f237d01.js"><link rel="prefetch" href="/assets/cookie和session.html.a0d88604.js"><link rel="prefetch" href="/assets/cors请求.html.75adfee9.js"><link rel="prefetch" href="/assets/oauth2.0和jwt.html.98027917.js"><link rel="prefetch" href="/assets/xss与csrf.html.39c0aadc.js"><link rel="prefetch" href="/assets/sort.html.2e202c22.js"><link rel="prefetch" href="/assets/base.html.3e451065.js"><link rel="prefetch" href="/assets/gymnastics.html.89f1976b.js"><link rel="prefetch" href="/assets/polyfill.html.cc955bd8.js"><link rel="prefetch" href="/assets/tsconfig.html.122eaa72.js"><link rel="prefetch" href="/assets/babel.html.40991aa5.js"><link rel="prefetch" href="/assets/code.html.32d80498.js"><link rel="prefetch" href="/assets/framework.html.400d3965.js"><link rel="prefetch" href="/assets/index.html.8d2cdc05.js"><link rel="prefetch" href="/assets/react-hooks.html.3a7b8c49.js"><link rel="prefetch" href="/assets/url.html.fe29cd6c.js"><link rel="prefetch" href="/assets/vue3.html.51ba8bdd.js"><link rel="prefetch" href="/assets/webassembly.html.9b67be9f.js"><link rel="prefetch" href="/assets/webpack1.html.a4ec7c3d.js"><link rel="prefetch" href="/assets/webpack2.html.a6cdda51.js"><link rel="prefetch" href="/assets/404.html.bc59af8a.js">
    <link rel="stylesheet" href="/assets/style.b933662a.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">Dragon的博客</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><!----><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><!----><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">javascript <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/js/event.html" class="sidebar-item" aria-label="事件循环机制/Event loop"><!--[--><!--]--> 事件循环机制/Event loop <!--[--><!--]--></a><!----></li><li><a href="/js/function.html" class="sidebar-item" aria-label="函数"><!--[--><!--]--> 函数 <!--[--><!--]--></a><!----></li><li><a href="/js/module.html" class="sidebar-item" aria-label="CommonJS、AMD、CMD、ESM、UMD"><!--[--><!--]--> CommonJS、AMD、CMD、ESM、UMD <!--[--><!--]--></a><!----></li><li><a href="/js/promise1.html" class="sidebar-item" aria-label="Promise--上"><!--[--><!--]--> Promise--上 <!--[--><!--]--></a><!----></li><li><a href="/js/promise2.html" class="sidebar-item" aria-label="Promise--下"><!--[--><!--]--> Promise--下 <!--[--><!--]--></a><!----></li><li><a href="/js/scope.html" class="sidebar-item" aria-label="作用域"><!--[--><!--]--> 作用域 <!--[--><!--]--></a><!----></li><li><a href="/js/class.html" class="sidebar-item" aria-label="类"><!--[--><!--]--> 类 <!--[--><!--]--></a><!----></li><li><a href="/js/new.html" class="sidebar-item" aria-label="new"><!--[--><!--]--> new <!--[--><!--]--></a><!----></li><li><a href="/js/let,var.html" class="sidebar-item" aria-label="let和var"><!--[--><!--]--> let和var <!--[--><!--]--></a><!----></li><li><a href="/js/this.html" class="sidebar-item" aria-label="this"><!--[--><!--]--> this <!--[--><!--]--></a><!----></li><li><a href="/js/bind.html" class="sidebar-item" aria-label="bind"><!--[--><!--]--> bind <!--[--><!--]--></a><!----></li><li><a href="/js/apply.html" class="sidebar-item" aria-label="call、apply"><!--[--><!--]--> call、apply <!--[--><!--]--></a><!----></li><li><a href="/js/equal.html" class="sidebar-item" aria-label="隐式转换 == 和 ==="><!--[--><!--]--> 隐式转换 == 和 === <!--[--><!--]--></a><!----></li><li><a href="/js/assign.html" class="sidebar-item" aria-label="Object.assign和...（展开运算符/扩展运算符）的区别 [已发帖]"><!--[--><!--]--> Object.assign和...（展开运算符/扩展运算符）的区别 [已发帖] <!--[--><!--]--></a><!----></li><li><a href="/js/instanceof.html" class="sidebar-item" aria-label="instanceof [已发帖]"><!--[--><!--]--> instanceof [已发帖] <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">typescript <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/typescript/tsconfig.html" class="sidebar-item" aria-label="tsconfig.json配置"><!--[--><!--]--> tsconfig.json配置 <!--[--><!--]--></a><!----></li><li><a href="/typescript/base.html" class="sidebar-item" aria-label="typescript基础"><!--[--><!--]--> typescript基础 <!--[--><!--]--></a><!----></li><li><a href="/typescript/polyfill.html" class="sidebar-item" aria-label="工具类的模拟实现"><!--[--><!--]--> 工具类的模拟实现 <!--[--><!--]--></a><!----></li><li><a href="/typescript/gymnastics.html" class="sidebar-item" aria-label="ts类型体操训练"><!--[--><!--]--> ts类型体操训练 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">前端相关 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/web/" class="sidebar-item" aria-label="索引"><!--[--><!--]--> 索引 <!--[--><!--]--></a><!----></li><li><a href="/web/webpack1.html" class="sidebar-item" aria-label="webpack"><!--[--><!--]--> webpack <!--[--><!--]--></a><!----></li><li><a href="/web/webpack2.html" class="sidebar-item" aria-label="webpack 和 vite"><!--[--><!--]--> webpack 和 vite <!--[--><!--]--></a><!----></li><li><a href="/web/url.html" class="sidebar-item" aria-label="浏览器从输入url发生了什么[未完...]"><!--[--><!--]--> 浏览器从输入url发生了什么[未完...] <!--[--><!--]--></a><!----></li><li><a href="/web/babel.html" class="sidebar-item" aria-label="babel"><!--[--><!--]--> babel <!--[--><!--]--></a><!----></li><li><a href="/web/webassembly.html" class="sidebar-item" aria-label="写一个WebAssembly/wasm包"><!--[--><!--]--> 写一个WebAssembly/wasm包 <!--[--><!--]--></a><!----></li><li><a href="/web/vue3.html" class="sidebar-item" aria-label="vue3源码[未完...]"><!--[--><!--]--> vue3源码[未完...] <!--[--><!--]--></a><!----></li><li><a href="/web/react-hooks.html" class="sidebar-item" aria-label="React Hooks源码"><!--[--><!--]--> React Hooks源码 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">web安全相关 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/security/xss%E4%B8%8Ecsrf.html" class="sidebar-item" aria-label="XSS和CSRF"><!--[--><!--]--> XSS和CSRF <!--[--><!--]--></a><!----></li><li><a href="/security/cors%E8%AF%B7%E6%B1%82.html" class="sidebar-item" aria-label="跨域请求"><!--[--><!--]--> 跨域请求 <!--[--><!--]--></a><!----></li><li><a href="/security/cookie%E5%92%8Csession.html" class="sidebar-item" aria-label="cookie 和 session"><!--[--><!--]--> cookie 和 session <!--[--><!--]--></a><!----></li><li><a href="/security/oauth2.0%E5%92%8Cjwt.html" class="sidebar-item" aria-label="OAuth2.0和JWT"><!--[--><!--]--> OAuth2.0和JWT <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading active">计算机网络相关 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/network/http.html" class="sidebar-item" aria-label="http"><!--[--><!--]--> http <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/network/tcp,udp.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="TCP/UDP"><!--[--><!--]--> TCP/UDP <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/network/tcp,udp.html#tcp的可靠性" class="router-link-active router-link-exact-active sidebar-item" aria-label="TCP的可靠性"><!--[--><!--]--> TCP的可靠性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/network/tcp,udp.html#tcp滑动窗口" class="router-link-active router-link-exact-active sidebar-item" aria-label="TCP滑动窗口"><!--[--><!--]--> TCP滑动窗口 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/network/tcp,udp.html#tcp拥塞控制" class="router-link-active router-link-exact-active sidebar-item" aria-label="TCP拥塞控制"><!--[--><!--]--> TCP拥塞控制 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/network/tcp,udp.html#流量控制" class="router-link-active router-link-exact-active sidebar-item" aria-label="流量控制"><!--[--><!--]--> 流量控制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/network/tcp,udp.html#慢启动" class="router-link-active router-link-exact-active sidebar-item" aria-label="慢启动"><!--[--><!--]--> 慢启动 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/network/tcp,udp.html#延迟确认" class="router-link-active router-link-exact-active sidebar-item" aria-label="延迟确认"><!--[--><!--]--> 延迟确认 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/network/tcp,udp.html#拥塞预防" class="router-link-active router-link-exact-active sidebar-item" aria-label="拥塞预防"><!--[--><!--]--> 拥塞预防 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/network/tcp,udp.html#tcp队头阻塞" class="router-link-active router-link-exact-active sidebar-item" aria-label="TCP队头阻塞"><!--[--><!--]--> TCP队头阻塞 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/network/tcp,udp.html#tcp快速重传和快速恢复" class="router-link-active router-link-exact-active sidebar-item" aria-label="TCP快速重传和快速恢复"><!--[--><!--]--> TCP快速重传和快速恢复 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/network/tcp,udp.html#tcp的time-wait累积与端口耗尽" class="router-link-active router-link-exact-active sidebar-item" aria-label="TCP的TIME_WAIT累积与端口耗尽"><!--[--><!--]--> TCP的TIME_WAIT累积与端口耗尽 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/network/tcp,udp.html#tcp-syn洪水-syn-flood-攻击" class="router-link-active router-link-exact-active sidebar-item" aria-label="TCP SYN洪水（SYN Flood)攻击"><!--[--><!--]--> TCP SYN洪水（SYN Flood)攻击 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/network/tcp,udp.html#udp" class="router-link-active router-link-exact-active sidebar-item" aria-label="UDP"><!--[--><!--]--> UDP <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/network/tcp,udp.html#tcp首部" class="router-link-active router-link-exact-active sidebar-item" aria-label="TCP首部"><!--[--><!--]--> TCP首部 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/network/tcp,udp.html#udp首部" class="router-link-active router-link-exact-active sidebar-item" aria-label="UDP首部"><!--[--><!--]--> UDP首部 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/network/tcp,udp.html#tcp性能聚焦" class="router-link-active router-link-exact-active sidebar-item" aria-label="TCP性能聚焦"><!--[--><!--]--> TCP性能聚焦 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/network/tcp,udp.html#参考" class="router-link-active router-link-exact-active sidebar-item" aria-label="参考"><!--[--><!--]--> 参考 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/network/tcp,udp.html#扩展链接" class="router-link-active router-link-exact-active sidebar-item" aria-label="扩展链接"><!--[--><!--]--> 扩展链接 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">java <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/java/springboot.html" class="sidebar-item" aria-label="springboot"><!--[--><!--]--> springboot <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">计算机图形学 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/graphics/fractal.html" class="sidebar-item" aria-label="分形图形"><!--[--><!--]--> 分形图形 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="tcp-udp" tabindex="-1"><a class="header-anchor" href="#tcp-udp" aria-hidden="true">#</a> TCP/UDP</h1><!----><h2 id="tcp的可靠性" tabindex="-1"><a class="header-anchor" href="#tcp的可靠性" aria-hidden="true">#</a> TCP的可靠性</h2><p>尽管TCP和UDP都使用相同的网络层（IP），TCP却向应用层提供与UDP完全不同的服务。 TCP提供一种面向连接的、可靠的字节流服务。</p><p>TCP通过下列方式来提供可靠性：</p><ul><li>应用数据被分割成TCP认为最适合发送的数据块。这和UDP完全不同，应用程序产生的数据报长度将保持不变。由TCP传递给IP的信息单位称为报文段或段（segment）。</li><li>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能 及时收到一个确认，将重发这个报文段。</li><li>当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送， 通常将推迟几分之一秒。</li><li>TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错， TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。</li><li>既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。</li><li>既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。</li><li>TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。</li></ul><h2 id="tcp滑动窗口" tabindex="-1"><a class="header-anchor" href="#tcp滑动窗口" aria-hidden="true">#</a> TCP滑动窗口</h2><p><img src="/assets/sliding_window.30d29b59.png" alt="image"> 在这个图中，我们将字节从 1至11进行标号。接收方通告的窗口称为提出的窗口（offered window），它覆盖了从第4字节到第9字节的区域，表明接收方已经确认了包括第 3字节在内的 数据，且通告窗口大小为 6。我们知道窗口大小是与确认序号相对应的。发送方计算它的可用窗口，该窗口表明多少数据可以立即被发送。当接收方确认数据后，这个滑动窗口不时地向右移动。窗口两个边沿的相对运动增加或 减少了窗口的大小。我们使用三个术语来描述窗口左右边沿的运动： <img src="/assets/sliding_window2.3386de56.png" alt="image"></p><ol><li>称窗口左边沿向右边沿靠近为窗口合拢。这种现象发生在数据被发送和确认时。</li><li>当窗口右边沿向右移动时将允许发送更多的数据，我们称之为窗口张开。这种现象发生在另一端的接收进程读取已经确认的数据并释放了 TCP的接收缓存时。</li><li>当右边沿向左移动时，我们称之为窗口收缩。 Host Requirements RFC强烈建议不要使 用这种方式。但TCP必须能够在某一端产生这种情况时进行处理。</li></ol><p>如果左边沿到达右边沿，则称其为一个零窗口，此时发送方不能够发送任何数据。</p><p>数据传输过程，滑动窗口的大小是动态的。 <img src="/assets/sliding_window3.1b62ba59.png" alt="image"></p><p>以该图为例可以总结如下几点：</p><ol><li>发送方不必发送一个全窗口大小的数据。</li><li>来自接收方的一个报文段确认数据并把窗口向右边滑动。这是因为窗口的大小是相对 于确认序号的。</li><li>正如从报文段7到报文段8中变化的那样，窗口的大小可以减小，但是窗口的右边沿却 不能够向左移动。</li><li>接收方在发送一个 ACK前不必等待窗口被填满。在前面我们看到许多实现每收到两个 报文段就会发送一个ACK。</li></ol><p>由接收方提供的窗口的大小通常可以由接收进程控制（吞吐量），这将影响TCP的性能， 一些应用可通过修改插口缓存大小来增加性能。</p><h2 id="tcp拥塞控制" tabindex="-1"><a class="header-anchor" href="#tcp拥塞控制" aria-hidden="true">#</a> TCP拥塞控制</h2><h3 id="流量控制" tabindex="-1"><a class="header-anchor" href="#流量控制" aria-hidden="true">#</a> 流量控制</h3><p>流量控制是一种预防发送端过多向接收端发送数据的机制。否则，接收端可能因为忙碌、负载重或缓冲区既定而无法处理。为实现流量控制，TCP 连接的每一方都要通告自己的<code>接收窗口（rwnd）</code>，其中包含能够保存数据的缓冲区空间大小 信息。</p><p>第一次建立连接时，两端都会使用自身系统的默认设置来发送 <code>rwnd</code>。浏览网页通常主要是从服务器向客户端下载数据，因此客户端窗口更可能成为瓶颈。然而，如果是在上传图片或视频，即客户端向服务器传送大量数据时，服务器的<code>接收窗口</code>又可能成为制约因素。不管怎样，如果其中一端跟不上数据传输，那它可以向发送端通告一个较小的窗口。假如窗口为零，则意味着必须由应用层先清空缓冲区，才能再接收剩余数据。这个过程贯穿于每个 TCP 连接的整个生命周期：每个 ACK 分组都会携带相应的最新 <code>rwnd</code>值，以便两端动态调整数据流速，使之适应发送端和接收端的容量及处理能力。</p><h3 id="慢启动" tabindex="-1"><a class="header-anchor" href="#慢启动" aria-hidden="true">#</a> 慢启动</h3><p>发送端和接收端在连接建立之初，谁也不知道可用带宽是多少，因此需要一个估算机制，然后还要根据网络中不断变化的条件 而动态改变速度。这个就是慢启动。慢启动算法通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。</p><p>慢启动如同字面意思，无论宽带多大，不可能一上来就完全利用最大的带宽。会从一开始传一点点，然后以一个规定的<code>指数式</code>计算得到的量增加。</p><p>慢启动为发送方的TCP增加了另一个窗口：<code>拥塞窗口(congestion window)</code>，记为cwnd。当与另一个网络的主机建立TCP连接时，<code>拥塞窗口</code>被初始化为1个报文段（即另一端通告的报文段大小）。每收到一个ACK，<code>拥塞窗口</code>就增加一个报文段（cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加）。发送方取<code>拥塞窗口</code>与通告窗口中的最小值作为发送上限。<code>拥塞窗口</code>是发送方使用的<code>流量控制</code>，而通告窗口则是接收方使用的<code>流量控制</code>。</p><p>在三次握手期间，客户端和服务器双方各自通过 ACK 分组通告自己的<code>接收窗口（rwnd）</code>大小。此时，根据交换数据来估算客户端与服务器之间的可用带宽是唯一的方法，而且这也是慢启动算法的设计思路。首先，服务器通过 TCP 连接初始化一个新的<code>拥塞窗口（cwnd）</code>变量，将其值设置为一个系统设定的保守值（在 Linux 中就是 initcwnd）。发送端不会通告 <code>拥塞窗口（cwnd）</code> 变量，即发送端和接收端不会交换这个值。此时，服务器只是维护这么一个私有变量。此时又有一条新规则，即客户端与服务器之间最大可以传输（未经 ACK 确认的）数据量取 <code>接收窗口（rwnd）</code> 和 <code>拥塞窗口（cwnd）</code> 中的最小值。因为网络随时在变化。慢启动就是这个时候用来动态算出这个最小值是rwnd还是cwnd。</p><h4 id="慢启动重启" tabindex="-1"><a class="header-anchor" href="#慢启动重启" aria-hidden="true">#</a> 慢启动重启</h4><p>慢启动导致客户端与服务器之间经过几百 ms 才能达到接近最大速度的问题，对于大型流式下载服务的影响倒不显著，因为慢启动的时间可以分摊到整个传输周期内消化掉。</p><p>可是，对于很多 HTTP 连接，特别是一些短暂、突发的连接而言，常常会出现还没有达到最大窗口请求就被终止的情况。换句话说，很多 Web 应用的性能经常受到服务器与客户端之间往返时间的制约。因为慢启动限制了可用的吞吐量，而这对于小文件传输非常不利。 对此，TCP除了提供调节新连接的传输速度，还提供了慢启动重启机制。这种机制会在连接空闲一定时间后重置连接的拥塞窗口。道理很简单，在连接空闲的同时，网络有可能发生了变化，为了避免拥塞，就需要将<code>拥塞窗口(cwnd)</code>重置回一个“安全的”默认值。</p><h3 id="延迟确认" tabindex="-1"><a class="header-anchor" href="#延迟确认" aria-hidden="true">#</a> 延迟确认</h3><p>由于因特网自身无法确保可靠的分组传输(因特网路由器超负荷的话，可以随意丢弃分组），所以TCP实现了自己的确认机制来确保数据的成功传输。每个TCP段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段 时，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者就认为分组已被破坏或损毁，并重发数据。由于确认报文很小，所以TCP允许在发往相同方向的输出数据分组中对其进行“捎带”。TCP将返回的确认信息与输出的数据分组结合在一起，可以更有效地利用网络。为了增加确认报文找到同向传输数据分组的可能性，很多TCP栈都实现了一种”延迟确认“算法。延迟确认算法会在一个特定的窗口时间（通常是100~200毫秒）内将输出确认存放在缓冲区中，以寻找能够捎带它的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。但是实际情况是，没那么多相反方向传数据分组捎带信息的机会。通常，延迟算法会引入相当大的时延。关闭 Nagle算法。一个典型的例子是 X窗口系统服务器：小消息（鼠标移动）必须无时延地发送，以便为进行某种操作的交互用户提供实时的反馈。</p><div class="custom-container tip"><p class="custom-container-title">Nagle算法</p><p>该算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去。该算法的优越之处在于它是自适应的：确认到达得越快，数据也就发送得越快。而在希望减少微小(小于报文段的大小)分组数目的低速广域网上，则会发送更少的分组。</p></div><h3 id="拥塞预防" tabindex="-1"><a class="header-anchor" href="#拥塞预防" aria-hidden="true">#</a> 拥塞预防</h3><p>慢启动以保守的窗口初始化连接，随后的每次往返都会成倍提高传输的数据量，直到超过接收端的流量控制窗口，即系统配置的拥塞阈值（ssthresh）窗口，或者有分组丢失为止，此时拥塞预防算法介入</p><p>拥塞预防算法把丢包作为网络拥塞的标志，即路径中某个连接或路由器已经拥堵了，以至于必须采取删包措施。因此，必须调整窗口大小，以避免造成更多的包丢失，从而保证网络畅通。</p><p>重置拥塞窗口后，拥塞预防机制按照自己的算法来增大窗口以尽量避免丢包。某个时刻，可能又会有包丢失，于是这个过程再从头开始。如果你看到过 TCP 连接的吞吐量跟踪曲线，发现该曲线呈锯齿状，那现在就该明白为什么了。这是拥塞控制和预防算法在调整拥塞窗口，进而消除网络中的丢包问题。</p><h2 id="tcp队头阻塞" tabindex="-1"><a class="header-anchor" href="#tcp队头阻塞" aria-hidden="true">#</a> TCP队头阻塞</h2><p>其实也就是TCP的数据流的机制导致的。</p><p>每个 TCP 分组都会带着一个唯一的序列号被发出，而所有分组必须按顺序传送到接收端。如果中途有一个分组没能到达接收 端，那么后续分组必须保存在接收端的 TCP 缓冲区，等待丢失的分组重发并到达接收端。这一切都发生在 TCP 层，应用程序对 TCP 重发和缓冲区中排队的分组一无所知，必须等待分组全部到达才能访问数据。在此之前，应用程序只能在通过套接字 读数据时感觉到延迟交付。这种效应称为 TCP 的队首（HOL，Head of Line）阻塞。</p><h2 id="tcp快速重传和快速恢复" tabindex="-1"><a class="header-anchor" href="#tcp快速重传和快速恢复" aria-hidden="true">#</a> TCP快速重传和快速恢复</h2><p>在收到一个失序的报文段时，TCP立即需要产生一个ACK（一个重复的ACK）。这个重复的ACK不应该被迟延。该重复的ACK的目的在于让对方知道收到一个失序的报文段，并告诉对方自己希望收到的序号。由于我们不知道一个重复的ACK是由一个丢失的报文段引起的，还是由于仅仅出现了几个报文段的重新排序，因此我们等待少量重复的ACK到来。假如这只是一些报文段的重新排 序，则在重新排序的报文段被处理并产生一个新的ACK之前，只可能产生1~2个重复的ACK。如果一连串收到3个或3个以上的重复ACK，就非常可能是一个报文段丢失了。于是我们就重传丢失的<code>数据报</code>文段，而无需等待超时定时器溢出。这就是<code>快速重传</code>算法。接下来执行的不是<code>慢启动</code>算法而是<code>拥塞避免</code>算法。这就是<code>快速恢复</code>算法。</p><h2 id="tcp的time-wait累积与端口耗尽" tabindex="-1"><a class="header-anchor" href="#tcp的time-wait累积与端口耗尽" aria-hidden="true">#</a> TCP的TIME_WAIT累积与端口耗尽</h2><p>TIME_WAIT状态也称为2MSL等待状态（MSL是Max Segment Lifetime最长报文寿命的缩写，通常2MSL就是2分钟）。</p><p>TIME_WAIT端口耗尽是影响到性能基准，但在现实中相对较少出现。</p><p>当某个TCP端点关闭TCP连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号。这类信息只会维持一小段时间，通常是所估计的最大分段使用期的两倍（称为2MSL，通常为2分钟）左右，以确保在这段时间内不会创建具有相同地址和端口号的新连接。实际上，这个算法可以防止在两分钟内创建、关闭并重新创建两个具有相同卫地址和端口号的连接。</p><p>通常没啥问题。但是在性能测试的时候，只用一台或几台来连接到某系统中去，这样限制了连接到服务器的客户端IP地址数。服务器默认TCP端口80上监听。用TIME_WAIT防止端口号重用时，如果服务器源端口号就60000个，在2MSL（假设是120秒）的时间内是无法重用的，连接率就等于60000/120 = 500次/秒。如果连接率不高于500次/秒，就不会遇见TIME_WAIT端口耗尽的问题。</p><h3 id="tcp-syn洪水-syn-flood-攻击" tabindex="-1"><a class="header-anchor" href="#tcp-syn洪水-syn-flood-攻击" aria-hidden="true">#</a> TCP SYN洪水（SYN Flood)攻击</h3><p>SYN Flood 属于典型的 DoS/DDoS 攻击。它是利用TCP协议设计中的缺陷。其攻击时，首先伪造大量的源I地址，分别向服务器端发送大量的<code>SYN包</code>此时服务器端会返回<code>SYN/ACK包</code>，因为源地址是伪造的，所以伪造的IP并不会应答，服务器 端没有收到伪造IP的回应，会重试3～5次并且等待一个<code>SYN Time</code>（一般为30秒至2分钟），如果超时则丢弃这个连接。攻击者大量发送这种伪造源地址的<code>SYN请求</code>，服务器端将会消耗非常多的资源(CPU和内存）来处理这种<code>半连接</code>，同时还要不断地对这些IP进行<code>SYN+ACK</code>重试。最后的结果是服务器无暇理睬正常的连接请求，导致拒绝服务。</p><p>应对攻击的方案：</p><ol><li>增加 SYN 连接，也就是增加<code>半连接队列</code>的容量。</li><li>减少 SYN + ACK 重试次数，避免大量的超时重发。</li><li>利用 SYN Cookie/SYN Proxy、safereset等算法。SYNCookie的主要恩想是为每-个IP地址分配一个“Cookie”，并统计每个IP地址的访问频率。如果在短时间内收到大量的来自同一个IP地址的数据包，则认为受到攻击，之后来自这个IP地址的包将被丢弃。</li></ol><p>在对抗DDOS的产品中，一般会综合使用各种算法，结合一些DDOS攻击的特征，对流量进行清洗。对抗DDOS的网络设备可以串联或者并联在网络出口处。但是DDOS依然是一个难题。当攻击流量超过了网络设备，甚至带宽的最大负荷时，网络任将瘫痪。一般来说，大型网站之所以看起来比较能”抗“DDOS攻击，是因为大型网站带宽比较充足，集群内服务器的数量也比较多。但一个集群的资源毕竟是有限的。遇见DDOS的流量达到数G到几十G，遇见这种情况，只能与网络运营商合作，共同完成DDOS攻击响应。DDOS攻击与防御是一个复杂的话题，需要深入研究。</p><h2 id="udp" tabindex="-1"><a class="header-anchor" href="#udp" aria-hidden="true">#</a> UDP</h2><p>比起TCP来讲，UDP更像是删掉了TCP的<code>确保可靠</code>的功能。</p><p>UDP是一个简单的面向<code>数据报</code>的运输层协议：进程的每个输出操作都正好产生一个UDP<code>数据报</code>，并组装成一份待发送的IP<code>数据报</code>。</p><p>这与面向流字符的协议不同，如TCP，应用程序产生的全体数据与真正发送的单个IP<code>数据报</code>可能没有什么联系。 UDP应用程序必须关心 IP<code>数据报</code>的长度。如果它超过网络的<code>MTU(最大传输单元)</code>，那么就要对IP数 据报进行分片。</p><p>TCP 是一个面向字节流的协议，能够以多个分组形式发送应用程序消息，且对分组中的消息范围没有任何明确限制。因此，连接的两端存在一个连接状态，每个分组都有序号，丢失还要重发，并且要按顺序交付。相对来说，UDP<code>数据报</code>有明确的限制：<code>数据报</code>必须封装在 IP 分组中，应用程序必须读取完整的消息。换句话说，<code>数据报</code>不能分片。所以单个的UDP最大<code>数据报</code>长度受到IP<code>数据报</code>限制。IP<code>数据报</code>的最大长度是65535字节，这是由IP首部16比特总长度字段所限制的。去除20字节的IP首部和8个字节的UDP首部，UDP<code>数据报</code>中用户数据的最长长度为65507字节。但是，大多数实现所提供的长度比这个最大值小。</p><div class="custom-container tip"><p class="custom-container-title">提示</p><p>数据报（datagram）和分组（packet）是两个经常被人混用的词，实际上它们还是 有区别的。分组可以用来指代任何格式化的数据块，而数据报则通常只用来描述那 些通过不可靠的服务传输的分组，既不保证送达，也不发送失败通知。正因为如此， 很多场合下人们都把 UDP 中 User（用户）的 U，改成 Unreliable（不可靠）的 U， 于是 UDP 就成了“不可靠数据报协议”（Unreliable Datagram Protocol）。这也是为 什么把 UDP 分组称为数据报更为恰当的原因。</p></div><h3 id="tcp首部" tabindex="-1"><a class="header-anchor" href="#tcp首部" aria-hidden="true">#</a> TCP首部</h3><p><img src="/assets/TCP1.7107dc1a.png" alt="image"><img src="/assets/TCP2.813f95dd.png" alt="image"></p><h3 id="udp首部" tabindex="-1"><a class="header-anchor" href="#udp首部" aria-hidden="true">#</a> UDP首部</h3><p><img src="/assets/UDP1.fac4a572.png" alt="image"><img src="/assets/UDP2.cd3e6d46.png" alt="image"></p><h2 id="tcp性能聚焦" tabindex="-1"><a class="header-anchor" href="#tcp性能聚焦" aria-hidden="true">#</a> TCP性能聚焦</h2><ol><li>TCP连接建立与握手</li><li>TCP慢启动拥塞控制</li><li>数据聚集的Nagle算法</li><li>用于稍带确认的TCP延迟确认Nagle算法</li><li>TIME_WAIT时延和端口耗尽</li></ol><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2><ul><li>《HTTP权威指南》</li><li>《TCP-IP详解卷一：协议》</li></ul><h2 id="扩展链接" tabindex="-1"><a class="header-anchor" href="#扩展链接" aria-hidden="true">#</a> 扩展链接</h2><ul><li><a href="http://www.ietf.org/rfc/rfc2001.txt" target="_blank" rel="noopener noreferrer">http://www.ietf.org/rfc/rfc2001.txt<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><ul><li>RFC2001,“TCP Slow Start, Congestion Avoidance,Fast Retransmit, and Fast Recovery Algorithms”(“TCP慢启动、避免拥塞、快速重传以及快速恢复算法”） 定义了TCP慢启动算法。</li></ul></li><li><a href="http://www.ietf.org/rfc/rfc1122.txt" target="_blank" rel="noopener noreferrer">http://www.ietf.org/rfc/rfc1122.txt<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><ul><li>RFC 1122, “Reauirements for Iaternet Hosts-Communication Layers”(“对因特 网主机的要求——通信层”）讨论了TCP确认和延迟确认。</li></ul></li><li><a href="http://www.ietf.org/rfc/rfc896.txt" target="_blank" rel="noopener noreferrer">http://www.ietf.org/rfc/rfc896.txt<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><ul><li>RFC 896. &quot;Congestion Control in IP/TCP Internetworks&quot;(“IP/TCP网络间的拥寒 控制”）是John Nagle千1984年发布的。描述了TCP拥塞控制的必要性。介绍 了现在称为“Nagle算法〞的算法•</li></ul></li><li><a href="http://www.ietf.org/rfc/rfc0813.txt" target="_blank" rel="noopener noreferrer">http://www.ietf.org/rfc/rfc0813.txt<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><ul><li>RFC 813. “Window and Acknowledgement Strategy in TCP”(“TCP中的窗口和 确认机制&quot;〉是一个早些年（1982年）制定的规范，它描述了TCP窗口和确认的 实现机制，解释了延迟确认技术的早期技术。</li></ul></li><li><a href="http://www.ietf.org/rfc/rfc0793.txt" target="_blank" rel="noopener noreferrer">http://www.ietf.org/rfc/rfc0793.txt<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><ul><li>REC 793. “Transmigsion Control Protocon（“传输控制协议&quot;），是Jon Postel于 1981年给出的TCP协议经典定义。</li></ul></li></ul></div><!--[--><!--]--></div><footer class="page-meta"><!----><!----><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/network/http.html" class="" aria-label="http"><!--[--><!--]--> http <!--[--><!--]--></a></span><!----></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.c901d27c.js" defer></script>
  </body>
</html>
